/*
*****************************************************************************
* Copyright (c) 1991. The University of Newcastle Research Associates Ltd.
*****************************************************************************
*
* PROGRAMMER :-     
*                   Industrial Electronics Division,
*                   TUNRA Ltd.,
*                   University of Newcastle, NSW 2308.
*
*****************************************************************************
*****************************************************************************
* MODULE :- BEACON                  File : SIMBEACO.C
****************************************************************************/

/************************************************************************/
/*																		*/
/*				SIMBEACO.C												*/
/*																		*/
/*      	    SIMULATOR FOR THE BEACON RECEIVER						*/
/*																		*/
/*	The purpose of this file is to allow testing of the ATCU			*/
/*	software in the absence of the physical beacon receiver.			*/
/*																		*/
/*	Programmer:	P. Moylan												*/
/*	Last modified:	27 May 1992											*/
/*	Status:		Working.												*/
/*																		*/
/*		Error in UpdateLevels: still have to convert the				*/
/*		dB value to volts.												*/
/*																		*/
/************************************************************************/

#include <general.h>
#include "simbeaco.h"		/* My own definition file				*/

#include <conio.h>		  	/* FROM conio IMPORT clrscr, cprintf, text_info	*/
#include <unosasm.h>		/* FROM unosasm IMPORT return_interrupt_status	*/
#include <dos.h>			/* FROM dos IMPORT disable, enable				*/
#include <unos.h>			/* FROM UNOS IMPORT timed_wait,					*/
							/*	create_semaphore, init_semaphore, wait		*/
							/*	_signal, timed_wait, create_task,			*/
							/*	SEMAPHORE_Q_TYPE							*/


#include <nvramext.h>			/* FROM STORE IMPORT beacon_details_struct,		*/
							/*	get_beacon_details, get_beacon_offset,		*/
							/*	fbyGetCurrentSatelliteNumber				*/
#include "orb_sim.h"		// Import get_bcn_sim () from orb_sim.c
#include "simintel.h"		// Import get_intelsat_sim_bcn()
#define HALF_SEC 		16

/************************************************************************/
/*			VARIABLES GLOBAL TO THIS MODULE								*/
/************************************************************************/

/* Maintenance page window.	*/

//private struct text_info *pstScreenInfo;

/* CurrentChannel is the currently selected channel.	*/

private unsigned int CurrentChannel = 15;

/* Array Level holds the simulated receiver levels for all channels.	*/

private double Level[16] = { 6.0,   5.0,    4.0,   3.0,
			     2.0,   1.0,    0.0,  -1.0,
			    -2.0,  -3.0,   -4.0,  -5.0,
			    -6.0,  -7.0,   -8.0,  -9.0 } ;

/* Semaphore to implement the Sleep operation.	*/

private unsigned int SimulatorSleepSem;

/* The most recent level generated by the simulator.	*/

private double SimulatedLevel;

/* Semaphore for synchronism with the data-gathering mechanism.  A	*/
/* signal on DataReady means that the current collection period is over	*/
/* and that the value of SimulatedLevel is available to be used.	*/

private unsigned int DataReady;

/* Flag to permit the detection of overrun errors.  DataTaken = TRUE	*/
/* means that we have taken a copy of SimulatedLevel and that		*/
/* SimulatedLevel is ready to receive a new value.  DataTaken = FALSE	*/
/* means that a new value has been loaded into SimulatedLevel but has	*/
/* not been read by the consumer.					*/

private BOOLEAN DataTaken = TRUE;

/* A semaphore on which the simulator task is initially blocked.  The	*/
/* only function of this semaphore is to start the simulator task at	*/
/* the right time.							*/

private unsigned int GoGadgetGo;

/************************************************************************/
/*		      EXTERNALLY ACCESSIBLE FUNCTIONS			*/
/************************************************************************/

void GoBeaconSimulator (void)

   /* Must be called when it is time to start the simulator task.	*/

   {
   _signal (GoGadgetGo);
   }

/************************************************************************/

double FetchSimulatorSample (void)

    /* Waits until the next sample is available, then returns it.  (It	*/
    /* is assumed that StartBeaconSimulator has been called - otherwise	*/
    /* this function will never return.)  Data overrun errors are	*/
    /* reported to the Alarm module, but not to the caller.		*/

    {
    double result;

    /* Wait for the end of the current collection period; then copy	*/
    /* the value of SimulatedLevel.					*/

    wait (DataReady);  result = SimulatedLevel;  DataTaken = TRUE;

    return result;
    }

/************************************************************************/

void SetSimulatorChannel (BYTE newchannel)

    /* Sets a new simulated beacon channel.	*/

    {
    BOOLEAN int_status = return_interrupt_status();

    disable();
    CurrentChannel = newchannel;
    if (int_status) enable ();
    }

/************************************************************************/
/*			    INTERNAL PROCEDURES				*/
/************************************************************************/
private void UpdateLevels (void)

	/* Simulates a level which is a sawtooth function, except for the	*/
	/* current channel where we use a more sophisticated simulation	*/
	/* supplied by function fdfGetSimulatorBeaconLevel in module SIMUL.	*/
	/* In fact module SIMUL calculates simulated values for all		*/
	/* channels, I believe, but it does not supply access functions for	*/
	/* the others.							*/

	{
	double incr = 0.1;
	unsigned int j;
	beacon_details_struct Details;
	float scale;

	get_beacon_details (&Details);
	scale = Details.gradient;

	for (j=0; j<16; j++)
	{
	if (Level[j] < -9.9)  Level[j] = 10.0;
	else Level[j] -= incr;
        }

    /* For the current channel, pick up a simulated value from function	*/
    /* fdfGetSimulatorBeaconLevel.  This is a value in dB, so we have	*/
    /* to convert it back to a value in volts.				*/
	// CurrentChannel
	Level[2] = scale * ( get_orb_sim_bcn ()
			+ get_beacon_offset(GetCurrentSatelliteNumber()));
	Level[1] = scale * ( get_intelsat_sim_bcn ()
			+ get_beacon_offset(GetCurrentSatelliteNumber()));

    }

/************************************************************************/

//=============================== IFDEF
#ifdef BEACON_SCR

void init_beacon_simulator_screen (tstDisplayPage* page)

    /* Puts titles on the screen.	*/

    {
	if (finGetScreen (page, pstScreenInfo))
    	{
	clrscr();  gotoxy (1, 1);
	cprintf ("            SIMULATED BEACON LEVELS (dB)\n\r"
			 "             by Simulated Beacon Number\n\r"
			 "[00]          [01]          [02]          [03]\n\r"
			 "[04]          [05]          [06]          [07]\n\r"
			 "[08]          [09]          [10]          [11]\n\r"
			 "[12]          [13]          [14]          [15]");
		fvdReleaseScreen (pstScreenInfo);
        }
    }

/************************************************************************/

void DisplaySimulatorLevels (tstDisplayPage* page)

	/* Displays the simulator output on a maintenance page.	*/

	{
	unsigned int j;

	if (finGetScreen (page, pstScreenInfo))
		{
		for ( j = 0 ; j < 16 ; j++ )
		{
			gotoxy (14*(j%4) + 6, j/4 + 3);
			cprintf ("%6.2f", Level[j]);
			}
		fvdReleaseScreen (pstScreenInfo);
		}
	}

#endif
//============================= IFDEF

/************************************************************************/
/*			     THE SIMULATOR TASK				*/
/************************************************************************/

private char BeaconSimulatorTaskName[] = "Beacon Simulator Task";

private void BeaconSimulatorTask (void* DummyVariable)

    /* Runs as a separate task, generating simulated beacon data.	*/

	{
	BOOLEAN int_status;
    BYTE channel;

	DummyVariable = DummyVariable;

    while (TRUE)
	{
	/* Time delay to give the correct sampling rate.	*/

	timed_wait (SimulatorSleepSem, HALF_SEC);

        /* Update our simulated beacon levels.	*/

		UpdateLevels ();

	/* Check for overrun errors, i.e. the situation where the	*/
	/* client module has not picked up the old SimulatedLevel.	*/

	//if (!DataTaken) fvdErrorSet (BEACON_SAMPLE_OVERRUN);

	int_status = return_interrupt_status();
	disable();  channel = CurrentChannel;
	if (int_status) enable ();

	/* Store the new simulated level.	*/

	SimulatedLevel = Level[channel];  DataTaken = FALSE;

	/* Signal that the new value is available.	*/

	_signal (DataReady);

	}
    }

/************************************************************************/
/*			MODULE INITIALIZATION				*/
/************************************************************************/

BOOLEAN InitBeaconSimulator (void)

    /* Must be called at the start of program execution.  If the result	*/
    /* FALSE is returned, initialization has failed.			*/

    {
    /* Create some semaphores.	*/

    SimulatorSleepSem = create_semaphore ();
    if (SimulatorSleepSem EQ 0xFFFF) return FALSE;
    init_semaphore (SimulatorSleepSem, 0, 1);

    DataReady = create_semaphore ();
    if (DataReady EQ 0xFFFF) return FALSE;
    init_semaphore (DataReady, 0, 1);

    GoGadgetGo = create_semaphore ();
    if (GoGadgetGo EQ 0xFFFF) return FALSE;
    init_semaphore (GoGadgetGo, 0, 1);
	/* Create a window. */
//	pstScreenInfo = fpstCreateWindow(6,19,61,24,LIGHTGRAY,BLACK,0,TEXT_MODE);

	/* Create the beacon simulator task.	*/
	cprintf ("Creating Beacon Simulator Task \r\n");
	if (!create_task ( BeaconSimulatorTaskName, PRIORITY_3, 0,
			TASK_BLOCKED, SEMAPHORE_Q_TYPE, GoGadgetGo,
			TASK_STACK_SIZE, 0, 0, NULL, BeaconSimulatorTask, NULL))
                        				return FALSE;

    return TRUE;
    }
